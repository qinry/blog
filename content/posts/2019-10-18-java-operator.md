---
title: "《Thinking in Java》 --  操作符"
date: 2019-10-18T21:55:03+08:00
tags: [ "java"]
---

# 操作符

## 静态导入
通过封装，自建类库已到达更简短语句答应字符串。可以静态导入（import static LibraryName）类库中静态对象

## 表达式
副作用：有些运算符可能会改变操作对象的值

一个表达式有多个操作符时，它们的优先级影响计算顺序，一般规则先乘除后加减，括号最先进行

`System.out.println()` 内含`+`</font> , 其前是String，其后操作对象非String会转换成String，如果它是String， 不用字符串转换。最后`+` 起到拼接作用

## 赋值( '=' )
* 基本类型，右值拷贝赋值给左值
* 对象，实际赋值操作是对象引用复制，可以理解为对象取多一个别名 

  注： 小心对象的赋值操作
一般不直接操作对象的域(形如 Object.field = value) ，容易导致混乱，违背良好的面向对象程序设计原则

## 算术操作符
### 加减乘除，取余运算
加号 `+`, 减号 `-`, 乘号`*`, 除号 `/`, 求模`%` ,以及它们和赋值 `=`</font> 的复合：`+=`，`-=`, `*=`, `/=`, `%=` 

注：%`%=` 作用于整数类型,以上是二元运算符

### 正负号
一元加减运算符`+`, `-` 。 减号结果返回操作数的相反数，但操作数不改变, 加号返回值符号不变， 如果类型是小类型（如：short ,byte, char）会提升类型为int,也不改原操作数

注：boolean不能进行加减乘除，取余运算
## 自增自减运算符
前缀自增自减是先算后返回 (如：++intVar)，后缀自增自减是先返回后算 (如：intVar++)

## 关系运算符
运算结果是boolean类型值(非false即true), 分别有 ```> , <, ==, !=, >=, <=```。等于和不等于适合所有的基本类型，其他比较运算符
对于boolean不适用

注：对象之间用 == 和 != 比较， 本质是引用上的比较，非内容的比较。比较内容用equals()方法(适用预定义好的类和自定义类覆盖equals()，新类equals()默认是比较引用)

## 逻辑运算符
非(!), 且(&&), 或(||)

#### 短路逻辑 
* && 前一个比较结果是false,后一个不用比较，整个结果是false 
* || 前一个比较结果是true，后一个不用比较, 整个结果是true

## 按位运算
按位且(&), 按位或(|), 按位取反(~),按位异或(^), 和赋值符号复合(&=, |=, ^=, 没有~=)

## 移位运算符
它们只能处理整数

* 有符号左移和右移运算符(<<和>>), 和赋值复合(<<= 和 >>=)

* Java特有的无符号右移(>>>)，和赋值复合(>>=)

移位的位数不能超过操作数本身的宽度，也就是说int类型移位不过32位，long类型不过64位

char, byte, short在移位时会转换为int类型, 返回结果也为int

注意：<<= 或 >>=，其左操作数会移动右操作数指定的位数，再将结果赋值给左操作数。byte, short 使用 >>>=，可能遇到问题(结果会出现-1)

## 类型转换操作符
形如：(type)value，具体可以写成 (byte)47;

基本类型可以互相转换(boolean除外), 对象也可以, 不过是派生类向上转型为基类或接口

* 窄化转换 -- 大类型降低为小类型, 会丢失一些信息
* 扩展转换 -- 小类型提升为大类型

## 三元操作符
形式: (boolean-exp) ? (true-result) : (false-true);

等价为条件判断语句

```java
if (boolean-exp)
    true-result;
else
    false-result;
```


## 字符串操作符
*  `+` </font> 将两个字符串拼接得到一个临时对象
*  `+=` </font> 将后字符串合并到前字符串，后字符串不改变

如果表达式第一个字符串起头，后续所有操作数必须是字符串型(编译器会把双引号内的字符串序列自动转成字符串)

## 截尾和舍入
### 截尾
类型转换会截尾, 浮点类型转换整数类型，会将浮点数小数点后的数忽略得到整数

### 舍入
使用Math.round()方法(在java.lang中，自动导入类，无须程序员导入)针对浮点数的四舍五入

## Java无sizeof
C和C++有sizeof操作符出现的原因是为了代码可移植性, 不同机器相同数据类型的字长可能不同。但Java中的数据类型的字长已经确定了，也就无需sizeof

## 当心溢出
* 上溢 -- 出现变量接受超过类型字长的值 或 运算结果超过类型值范围
* 下溢 -- 大类型转换小类型，会截尾导致部分信息丢失

## 生成随机数的类
java.util 中有 Random类用于生成随机数列, 有成员方法nextInt(int), nextFloat(), nextLong(), nextDouble() 返回对应的类型值
用法如下:


```java
Random rand = Random(47);
int i = rand.nextInt(20); // 生成 0 ~ 19 中的数， 不包括
float f = rand.nextFloat();
double d  = rand.nextDouble();
long l = rand.nextLong();
```
